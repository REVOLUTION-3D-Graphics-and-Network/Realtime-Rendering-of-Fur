#version 430

layout(local_size_x = 1, local_size_y = 1) in;
layout(rgba16f, binding = 0) uniform readonly image2D img_rest_pos;
layout(rgba16f, binding = 1) uniform readonly image2D img_last_pos; // Position in the last frame
layout(rgba16f, binding = 2) uniform readonly image2D img_current_pos; // Position in the current frame
layout(rgba16f, binding = 3) uniform writeonly image2D img_simulated_pos; // Position in the new frame (simulated)

// Do not forget to change this if it is changed in main.
// Casting a uniform to const did not seem to work..
const int noOfHairSegments = 8;

float hairSegmentLength = 0.05f;

void fullfillEdgeConstraint(inout vec4 p1, inout vec4 p2, int index);

void main() {

    /***************************************************/
    /**************** Initialization *******************/
    /***************************************************/

    ivec2 texCoords[noOfHairSegments];
    vec4 rest_pos[noOfHairSegments];
    vec4 last_pos[noOfHairSegments];
    vec4 curr_pos[noOfHairSegments];
    vec4 new_pos[noOfHairSegments];
    vec4 curr_vel[noOfHairSegments];

    // Initialize positions and velocities for each hair vertex.
    for(int i = 0; i < noOfHairSegments; i++){
        texCoords[i] = ivec2(gl_GlobalInvocationID.xy) + ivec2(i, 0);
        rest_pos[i] = imageLoad(img_rest_pos, texCoords[i]);
        last_pos[i] = imageLoad(img_last_pos, texCoords[i]);
        curr_pos[i] = imageLoad(img_current_pos, texCoords[i]);

        new_pos[i] = curr_pos[i];
        curr_vel[i] = curr_pos[i] - last_pos[i];
    }

    /***************************************************/
    /*************** Simulation step *******************/
    /***************************************************/

    float dt = 0.03;

    /******************* Integration *******************/
    vec4 gravity = vec4(0.f, -9.82, 0.f, 0.f);
    for(int i = 1; i < noOfHairSegments; i++){
        new_pos[i] = curr_pos[i] + curr_vel[i] + gravity * pow(dt, 2);
    }

    /*************** Global constraints ****************/
    float max_c_strength = 0.1f;
    float constraint_strength = max_c_strength;
    for(int i = 0; i < noOfHairSegments; i++){
        new_pos[i] = new_pos[i] + constraint_strength * (rest_pos[i] - new_pos[i]);
        constraint_strength = constraint_strength - (max_c_strength/noOfHairSegments);
    }
    /*************** Local constraints *****************/
    // TODO: Add local constraints

    /************ Edge/Length constraints **************/
    int maxIter = 2;
    int iter = 0;
    while(iter < maxIter){
        for(int i = 0; i < noOfHairSegments-1; i++){
            fullfillEdgeConstraint(new_pos[i], new_pos[i+1], i);
        }
        iter++;
    }
    /***************************************************/
    /***************************************************/

    // Finally, set the new position in the correct texel in the output texture
    for(int i = 0; i < noOfHairSegments; i++){
        imageStore(img_simulated_pos, texCoords[i], new_pos[i]);
    }
}

void fullfillEdgeConstraint(inout vec4 p1, inout vec4 p2, int index){
    vec4 n = normalize(p1 - p2);
    float deltaD = length(p1 - p2) - hairSegmentLength;
    vec4 dP1, dP2;
    if(index == 0){
        dP1 = vec4(0.f);
        dP2 = deltaD * n;
    } else {
        dP1 = -0.5 * deltaD * n;
        dP2 =  0.5 * deltaD * n;
    }

    p1 = p1 + dP1;
    p2 = p2 + dP2;
}